package fr.utbm.ia54.simulationorca.sarlskill

import java.util.List
import fr.utbm.ia54.simulationorca.environmentmodel.Obstacle
import java.util.ArrayList

import fr.utbm.ia54.simulationorca.framework.Constants
import fr.utbm.ia54.simulationorca.framework.Line
import fr.utbm.ia54.simulationorca.sarlcapacity.ComputeNextMoveCapacity
import fr.utbm.ia54.simulationorca.framework.Vector
import fr.utbm.ia54.simulationorca.environmentmodel.AgentBody

skill ComputeORCASkill implements ComputeNextMoveCapacity {
	
	var bodyPos : Vector
	var bodyVelocity : Vector
	var finalPos : Vector
	var newVelocity : Vector
	
	new (position : Vector, finalPosition : Vector) {
	    super()
	    finalPos = finalPosition
	}
	
	def nextMove (perceptions : List<Object>, body : AgentBody): Vector {

//		bodyPos = new Vector( (Math.random()*500 +1) as int,(Math.random()*500 +1) as int)
		var obstacles = new ArrayList<Obstacle>
		var neighbours = new ArrayList<AgentBody>
	
		for (elt : perceptions){
			switch (elt.class) {
					case typeof(Obstacle) : { 
						obstacles.add(elt as Obstacle);
					} 
					case typeof(AgentBody) : {
						neighbours.add(elt as AgentBody);
					}
					default : {
						println("ComputeORCASkill - Unknown type in the perception list : " + elt.class)
					}
			}
		}
		
				
		bodyPos = body.position
		bodyVelocity = body.velocity
		newVelocity = new Vector(0,0)
		
		var orcaLines = <Line>newArrayList
		
		if(!obstacles.isEmpty){		
			orcaLines = orcaLinesForObstacles(obstacles)
		}
		var numObstLines = orcaLines.size
		if(!neighbours.isEmpty){
			orcaLines += orcaLinesForNeighbours(orcaLines, neighbours)			
		}
		
		var maxSpeed = Constants.MAX_SPEED //XXX what is this thing ...
		
		/*
		 *  XXX finalPos = prefVelocity ?  
		 *  non j'avais lu trop vite: voir dans exampleBlock.cpp setPreferredVelocities() ligne 161
		 *  prefVelocity = finalPos-BodyPos (a normaliser au besoin)
		 */
		var prefVelocity=finalPos.minus(bodyPos)
		if (prefVelocity.absSq > 1.0f) {
			prefVelocity = prefVelocity.normalize;
		}
		
		var lineFail = linearProgram2(orcaLines, maxSpeed,prefVelocity , false); 

		if (lineFail < orcaLines.size) {
			linearProgram3(orcaLines, numObstLines, lineFail, maxSpeed);
		}

		return newVelocity
	}
	
	def orcaLinesForObstacles(obstacles : List<Obstacle>) : ArrayList<Line>{
		var orcaLines = new ArrayList<Line>
		
		for (obstacle : obstacles){
			//TODO Obstacles avoidance
		}
		
		return orcaLines;
	}
	
	def orcaLinesForNeighbours(orcaLines : List<Line>, neighbours : List<AgentBody>) : List<Line> {
		
		var invTimeHorizon = 1/Constants.TIME_HORIZON // XXX check what that variable stands for ! seems like a key point
		var timeStep = Constants.TIME_STEP
		
		for (neighbour : neighbours){
			
			var relativePosition = neighbour.position.minus(bodyPos)
			var relativeVelocity = neighbour.velocity.minus(bodyVelocity)
			var distSq = relativePosition.absSq()
			var combinedRadius = Constants.PEDSTRIAN_CIRCLE_DIAMETER //"the radius of the circular constraint" XXX check if correct
			var combinedRadiusSq = Math.pow(combinedRadius, 2)
			
			var line = new Line
			var u : Vector
			
			if(distSq > combinedRadiusSq){
				
				// No collision
				var w = relativeVelocity.minus(relativePosition.prod(-invTimeHorizon))
				// Vector from cutoff center to relative velocity
				var wLengthSq = w.absSq()
				
				var dotProduct1 : float = w.prod(relativePosition)
				
				if(dotProduct1 < 0 && Math.pow(dotProduct1, 2) > combinedRadiusSq * wLengthSq){
					// Project on cutoff circle
					var wLength = Math.sqrt(wLengthSq) as float
					var unitW = w.divide(wLength)
					
					line.direction = new Vector(unitW.y, -unitW.x)
					u = unitW.prod(combinedRadius * invTimeHorizon - wLength)
				} else {
					// Project on legs
					var leg = Math.sqrt(distSq - combinedRadiusSq) as float

					if(relativePosition.det(w) > 0){
						var temp = new Vector(relativePosition.x * leg - relativePosition.y * combinedRadius, relativePosition.x * leg + relativePosition.y * combinedRadius)
						line.direction = temp.divide(distSq)
					} 
					else {
						var temp = new Vector(relativePosition.x * leg + relativePosition.y * combinedRadius, -relativePosition.x * leg + relativePosition.y * combinedRadius)
						temp = temp.prod(-1)
						line.direction = temp.divide(distSq)
					}
					
					var dotProduct2 = relativeVelocity.prod(line.direction)
					u = (line.direction.prod(dotProduct2)).minus(relativeVelocity)
				}
			} else {
				// Collision
				// Project on cutoff circle of time timeStep
				var invTimeStep = 1 / timeStep
				
				// Vector from cutoff center to relative velocity
				var w = relativePosition.prod(-invTimeStep)
				
				var wLength = w.abs()
				var unitW = w.divide(wLength)
				line.direction = new Vector(unitW.y, -unitW.x)
				u = unitW.prod(combinedRadius * invTimeStep - wLength)				
			}
			
			line.point = bodyVelocity.plus(u.prod(0.5 as float))
			orcaLines.add(line)
		}
		
		return orcaLines;
	}
	
	
	def linearProgram1(orcaLines : List<Line>, lineNb : int, radius : float, optVelocity : Vector, directionOpt : boolean ) : boolean {
		
		var point = orcaLines.get(lineNb).point
		var direction = orcaLines.get(lineNb).direction
		
		var dotProduct = point.prod(direction)
		var discriminant = Math.pow(dotProduct,2) + Math.pow(radius,2) - point.absSq
		
		if (discriminant < 0) {
			// Max speed circle fully invalidates line lineNb
			return false;
		}
		
		var sqrtDiscriminant = Math.sqrt(discriminant) as float;
		var tLeft = -dotProduct - sqrtDiscriminant;
		var tRight = -dotProduct + sqrtDiscriminant;
		
		for(var i = 0; i < lineNb; i++){
			 var denominator = direction.det(orcaLines.get(i).direction);
			 var numerator = orcaLines.get(i).direction.det(point.minus(orcaLines.get(i).point));
			 
			 if(Math.abs(denominator) <= Constants.EPSILON){
			 	// Lines lineNb and i are (almost) parallel
				if (numerator < 0) {
					return false;
				} 
			 }
			 else{
			 	var t = numerator / denominator;
				 if (denominator >= 0) {
					// Line i bounds line lineNb on the right
					tRight = Math.min(tRight, t);
				 }
				 else {
					// Line i bounds line lineNb on the left
					tLeft = Math.max(tLeft, t);
				 }
				
				 if (tLeft > tRight) {
					 return false;
				 }
			 } 
			 
			 
		}
		
		if (directionOpt) {
			// Optimize direction
			if (optVelocity.prod(direction) > 0){
				// Take right extreme
				newVelocity = point.plus(direction.prod(tRight));
			}
			else {
				// Take left extreme
				newVelocity = point.plus(direction.prod(tLeft))
			}
		}
		else {
			/* Optimize closest point. */
			var t = direction.prod(optVelocity.minus(point));
			
			if (t < tLeft) {
				newVelocity = point.plus(direction.prod(tLeft));
			}
			else if (t > tRight) {
				newVelocity = point.plus(direction.prod(tRight));
			}
			else {
				newVelocity = point.plus(direction.prod(t));
			}
		}

		return true;
	}
	
	def linearProgram2( orcaLines : List<Line>, radius : float, optVelocity : Vector, directionOpt : boolean) : int {
		
		if (directionOpt) {
			// Optimize direction. Note that the optimization velocity is of unit length in this case
			newVelocity = optVelocity.prod(radius);
		} else if (optVelocity.absSq > Math.pow(radius,2)) {
			// Optimize closest point and outside circle
			newVelocity = (optVelocity.normalize).prod(radius);
		} else {
			// Optimize closest point and inside circle
			newVelocity = optVelocity;
		}
		
		for(var i = 0; i < orcaLines.size; i++){
			var direction = orcaLines.get(i).direction
			var point = orcaLines.get(i).point

			if(direction.det(point.minus(newVelocity)) > 0){
				
				// Result does not satisfy constraint i, compute new optimal result
				var tempVelocity = newVelocity
				if(!linearProgram1(orcaLines, i, radius, optVelocity, directionOpt)){
					newVelocity = tempVelocity
					return i;
				}
			}
		}
		
		return orcaLines.size;
	}
	
	def linearProgram3(orcaLines : List<Line>, numObstLines : int, beginLine : int, radius : float){
		var distance = 0.0 as float;
		
		for (var i = beginLine; i < orcaLines.size(); i++) {
			
			var directionI = orcaLines.get(i).direction
			var pointI = orcaLines.get(i).point
		
			if (directionI.det(pointI.minus(newVelocity)) > distance) {
				// Result does not satisfy constraint of line i
				var projLines = new ArrayList<Line>
				projLines += orcaLines.get(0)
				projLines += orcaLines.get(numObstLines) //XXX check if equivalent to lines.begin() + static_cast<ptrdiff_t>(numObstLines))
				
				for (var j = numObstLines; j < i; j++) {
					var directionJ = orcaLines.get(j).direction
					var pointJ = orcaLines.get(j).point
					
					var line = new Line
					var determinant = directionI.det(directionJ)
					
					if (Math.abs(determinant) <= Constants.EPSILON) {
						// Line i and line j are parallel
						if (directionI.prod(directionJ) <= 0.0f) {
							// Line i and line j point in opposite direction
							line.point = (pointI.plus(pointJ)).prod(0.5 as float)
							line.direction = (directionJ.minus(directionI)).normalize
							projLines += line;
						}
					}
					else {
						var coef = directionJ.det(pointI.minus(pointJ)) / determinant
						line.point = pointI.plus(directionI.prod(coef))
						line.direction = (directionJ.minus(directionI)).normalize
						projLines += line;
					}
					 
				}
				
				var tempVelocity = newVelocity
				var vector = new Vector(-directionI.y, directionI.x)
								
				if (linearProgram2(projLines, radius, vector, true) < projLines.size) {
					newVelocity = tempVelocity
				}
				distance = directionI.det(pointI.minus(newVelocity))
			}	
		}
	}
}
