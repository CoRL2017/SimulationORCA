package fr.utbm.ia54.simulationorca.sarlagent

import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Initialize
import io.sarl.core.Lifecycle
import java.util.List
import io.sarl.lang.core.Address
import fr.utbm.ia54.simulationorca.framework.Position
import fr.utbm.ia54.simulationorca.framework.Constants
import fr.utbm.ia54.simulationorca.environmentmodel.AgentBody
import java.util.ArrayList
import fr.utbm.ia54.simulationorca.environmentmodel.Obstacle
import fr.utbm.ia54.simulationorca.sarlevent.PerceptionEvent
import io.sarl.util.Scopes
import fr.utbm.ia54.simulationorca.sarlcapacity.ComputePerceptionCapacity
import fr.utbm.ia54.simulationorca.sarlcapacity.ResolveConflictCapacity
import io.sarl.core.Schedules
import fr.utbm.ia54.simulationorca.sarlskill.ComputePerceptionSkill
import fr.utbm.ia54.simulationorca.sarlskill.ResolveConflictSkill
import io.sarl.core.Behaviors
import fr.utbm.ia54.simulationorca.sarlevent.EndOfStepEvent
import fr.utbm.ia54.simulationorca.sarlevent.SimulationStepEvent
import fr.utbm.ia54.simulationorca.gui.EnvironmentListener
import fr.utbm.ia54.simulationorca.sarlskill.UpdateEnvironmentSkill
import fr.utbm.ia54.simulationorca.sarlcapacity.UpdateEnvironmentCapacity
import java.util.HashMap
import java.util.Map
import java.util.HashSet
import fr.utbm.ia54.simulationorca.sarlevent.InfluenceEvent

agent Environment{
	
	uses DefaultContextInteractions, Lifecycle, Behaviors,ComputePerceptionCapacity,ResolveConflictCapacity,UpdateEnvironmentCapacity,Schedules
	
	var hashAgentBodies : Map<Address,AgentBody> = new HashMap<Address,AgentBody>
	var listObstacles : List<Obstacle> = new ArrayList<Obstacle>
	var listListeners : List<EnvironmentListener> = new ArrayList<EnvironmentListener>
	
	on Initialize{
		// Set skills
		var skillCompute = new ComputePerceptionSkill
    	setSkill(ComputePerceptionCapacity, skillCompute)
    	var skillResolve = new ResolveConflictSkill
		setSkill(ResolveConflictCapacity, skillResolve)
		var skillUpdate = new UpdateEnvironmentSkill()
		setSkill(UpdateEnvironmentCapacity, skillUpdate)
				
		println("in Initialize")
		listObstacles=occurrence.parameters.get(2) as List<Obstacle>
		spawnPedestrianBodies(occurrence.parameters.get(0) as List<Address>, occurrence.parameters.get(1) as List<Position>)
		listListeners.add(occurrence.parameters.get(3) as EnvironmentListener)
		
		
		fireUpdateFrame
		
		wake(new SimulationStepEvent)
		
		every(Constants.TIMEOUT)[
			wake(new EndOfStepEvent)	
		]

	}
	
	on SimulationStepEvent{
		println("in SimulationStepEvent")
		
		for (body as AgentBody : hashAgentBodies.values()) {
		 	//use the skill computePerception
			var perceptions : List<Object> = computePerception(body.position, new ArrayList(hashAgentBodies.values()), listObstacles)
			emit(new PerceptionEvent(body.position, perceptions),Scopes.addresses(body.pedestrianAddress))
		}
	}
	
	on EndOfStepEvent{
		println("in EndOfStepEvent")
		//use skill ResolveConflictSkill
		resolveConflict
		// Fire update signal to the listeners
		fireUpdateFrame
		//do an other step of Simulation
		wake(new SimulationStepEvent)
	}
	
	on InfluenceEvent{
		println("in InfuenceReceivedEvent")
		var agentTemp : AgentBody = new AgentBody(occurrence.source,occurrence.bodyPos)
		hashAgentBodies.put(occurrence.source, agentTemp)	
	}
	
	def fireUpdateFrame(){
		for(listener as EnvironmentListener : listListeners){
			listener.updateGraphics(new HashSet(hashAgentBodies.values()))			
		}
	}
	
	def spawnPedestrianBodies(listPedestrianAdresses : List<Address>, listInitialPositions : List<Position>){
		for(var i=0; i<listPedestrianAdresses.size(); i++){
			hashAgentBodies.put(listPedestrianAdresses.get(i),new AgentBody(listPedestrianAdresses.get(i), listInitialPositions.get(i)))
		}
	}
	
}